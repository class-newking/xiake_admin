from django.core.management.base import BaseCommand
from django.db import connections
from django.db.utils import OperationalError
from django.apps import apps
from django.apps.config import AppConfig
import os


class Command(BaseCommand):
    help = 'Sync database tables without using migrations'

    def add_arguments(self, parser):
        parser.add_argument(
            '--database',
            default='default',
            help='Nominates a database to sync. Defaults to the "default" database.',
        )
        parser.add_argument('app_label', nargs='?', help='App label of an application to sync.')
        parser.add_argument('model_name', nargs='?', help='Model name to sync.')

    def handle(self, *args, **options):
        database = options['database']
        app_label = options['app_label']
        model_name = options['model_name']

        self.stdout.write(f'Syncing database: {database}')

        # 获取项目根目录并创建sql.txt文件路径
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
        sql_file_path = os.path.join(base_dir, 'sql.txt')

        # 清空或创建sql.txt文件
        with open(sql_file_path, 'w') as f:
            f.write('-- SQL Statements Generated by syncdb command\n')
            f.write('-- ===========================================\n\n')

        # 如果没有传参数，生成所有app的SQL
        if not app_label:
            self.stdout.write('Processing all apps')
            # 获取所有已安装的应用
            app_configs = apps.get_app_configs()

            # 过滤掉Django自带的组件(以django.contrib开头的app)
            app_configs = [app_config for app_config in app_configs if not app_config.name.startswith('django.contrib')]

            # 为所有模型生成SQL语句并写入文件
            for app_config in app_configs:
                self.stdout.write(f'Processing app: {app_config.label}')
                try:
                    self.create_tables_for_app(app_config, database, sql_file_path)
                except Exception as e:
                    self.stdout.write(
                        self.style.ERROR(f'Error creating tables for {app_config.label}: {str(e)}')
                    )
        # 如果传了一个参数，只处理指定app
        elif app_label and not model_name:
            try:
                app_config = apps.get_app_config(app_label)
                # 过滤掉Django自带的组件
                if app_config.name.startswith('django.contrib'):
                    self.stdout.write(
                        self.style.ERROR(f'Cannot process Django built-in app "{app_label}"')
                    )
                    return

                self.stdout.write(f'Processing app: {app_config.label}')
                self.create_tables_for_app(app_config, database, sql_file_path)
            except LookupError:
                self.stdout.write(
                    self.style.ERROR(
                        f'App "{app_label}" not found. Available apps: {", ".join([app.label for app in apps.get_app_configs()])}')
                )
                return
        # 如果传了两个参数，只处理指定app下的指定model
        else:
            try:
                app_config = apps.get_app_config(app_label)
                # 过滤掉Django自带的组件
                if app_config.name.startswith('django.contrib'):
                    self.stdout.write(
                        self.style.ERROR(f'Cannot process Django built-in app "{app_label}"')
                    )
                    return

                try:
                    model = app_config.get_model(model_name)
                    self.create_table_for_model(model, database, sql_file_path)
                except LookupError:
                    self.stdout.write(
                        self.style.ERROR(
                            f'Model "{model_name}" not found in app "{app_label}". Available models: {", ".join([m.__name__ for m in app_config.get_models()])}')
                    )
                    return
            except LookupError:
                self.stdout.write(
                    self.style.ERROR(
                        f'App "{app_label}" not found. Available apps: {", ".join([app.label for app in apps.get_app_configs()])}')
                )
                return

        self.stdout.write(
            self.style.SUCCESS(f'Successfully generated SQL statements in {sql_file_path}')
        )

    def create_tables_for_app(self, app_config, database, sql_file_path):
        # 获取应用中的所有模型
        models = app_config.get_models()

        for model in models:
            self.create_table_for_model(model, database, sql_file_path)

    def create_table_for_model(self, model, database, sql_file_path):
        # 获取数据库连接
        connection = connections[database]

        # 获取模型对应的创建表SQL
        with connection.schema_editor() as schema_editor:
            try:
                # 生成创建表的SQL语句而不是实际创建表
                table_name = model._meta.db_table
                schema_editor.deferred_sql = []  # 清空之前的SQL语句

                # 修复DatabaseSchemaEditor缺少_create_table_sql方法的问题
                # 使用正确的API来生成SQL语句
                sql_statement = schema_editor.sql_create_table % {
                    "table": schema_editor.quote_name(table_name),
                    "definition": schema_editor._model_to_create_sql(model),
                }

                # 将SQL语句写入文件
                with open(sql_file_path, 'a') as f:
                    f.write(f'-- Table: {table_name}\n')
                    f.write(f'{sql_statement};\n')

                    # 添加其他相关的SQL语句（如索引等）
                    for deferred_sql in schema_editor.deferred_sql:
                        if hasattr(deferred_sql, 'template'):
                            f.write(f'{deferred_sql.template % deferred_sql.parts};\n')
                        else:
                            f.write(f'{deferred_sql};\n')

                    f.write('\n')

                self.stdout.write(f'  Generated SQL for table {table_name}')
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'    Error generating SQL for {model._meta.db_table}: {str(e)}')
                )

    # 添加一个辅助方法来生成模型的SQL定义
    def _model_to_create_sql(self, schema_editor, model):
        """
        生成模型的CREATE TABLE语句定义部分
        """
        # 收集所有字段的SQL定义
        column_sqls = []
        for field in model._meta.local_fields:
            # 获取字段的SQL定义
            field_sql = schema_editor.column_sql(model, field)
            column_sqls.append(
                "%s %s" % (
                    schema_editor.quote_name(field.column),
                    field_sql,
                )
            )

        # 添加主键约束
        if model._meta.pk and model._meta.pk.column:
            column_sqls.append(
                "PRIMARY KEY (%s)" % schema_editor.quote_name(model._meta.pk.column)
            )

        return ", ".join(column_sqls)
