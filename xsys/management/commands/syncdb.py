from django.core.management.base import BaseCommand
from django.db import connections
from django.db.utils import OperationalError
from django.apps import apps
from django.apps.config import AppConfig
import os


class Command(BaseCommand):
    help = 'Sync database tables without using migrations'

    def add_arguments(self, parser):
        parser.add_argument(
            '--database',
            default='default',
            help='Nominates a database to sync. Defaults to the "default" database.',
        )
        parser.add_argument('app_label', nargs='?', help='App label of an application to sync.')
        parser.add_argument('model_name', nargs='?', help='Model name to sync.')

    def handle(self, *args, **options):
        database = options['database']
        app_label = options['app_label']
        model_name = options['model_name']

        self.stdout.write(f'Syncing database: {database}')

        # 获取项目根目录并创建sql.txt文件路径
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
        sql_file_path = os.path.join(base_dir, 'sql.txt')

        # 清空或创建sql.txt文件
        with open(sql_file_path, 'w') as f:
            f.write('-- SQL Statements Generated by syncdb command\n')
            f.write('-- ===========================================\n\n')

        # 如果没有传参数，生成所有app的SQL
        if not app_label:
            self.stdout.write('Processing all apps')
            # 获取所有已安装的应用
            app_configs = apps.get_app_configs()

            # 过滤掉Django自带的组件(以django.contrib开头的app)
            app_configs = [app_config for app_config in app_configs if not app_config.name.startswith('django.contrib')]

            # 为所有模型生成SQL语句并写入文件
            for app_config in app_configs:
                self.stdout.write(f'Processing app: {app_config.label}')
                try:
                    self.create_tables_for_app(app_config, database, sql_file_path)
                except Exception as e:
                    self.stdout.write(
                        self.style.ERROR(f'Error creating tables for {app_config.label}: {str(e)}')
                    )
        # 如果传了一个参数，只处理指定app
        elif app_label and not model_name:
            try:
                app_config = apps.get_app_config(app_label)
                # 过滤掉Django自带的组件
                if app_config.name.startswith('django.contrib'):
                    self.stdout.write(
                        self.style.ERROR(f'Cannot process Django built-in app "{app_label}"')
                    )
                    return

                self.stdout.write(f'Processing app: {app_config.label}')
                self.create_tables_for_app(app_config, database, sql_file_path)
            except LookupError:
                available_apps = ", ".join([app.label for app in apps.get_app_configs()])
                self.stdout.write(
                    self.style.ERROR(
                        f'App "{app_label}" not found. Available apps: {available_apps}')
                )
                return
        # 如果传了两个参数，只处理指定app下的指定model
        else:
            try:
                app_config = apps.get_app_config(app_label)
                # 过滤掉Django自带的组件
                if app_config.name.startswith('django.contrib'):
                    self.stdout.write(
                        self.style.ERROR(f'Cannot process Django built-in app "{app_label}"')
                    )
                    return

                try:
                    model = app_config.get_model(model_name)
                    self.create_table_for_model(model, database, sql_file_path)
                except LookupError:
                    available_models = ", ".join([m.__name__ for m in app_config.get_models()])
                    self.stdout.write(
                        self.style.ERROR(
                            f'Model "{model_name}" not found in app "{app_label}". '
                            f'Available models: {available_models}')
                    )

                    return
            except LookupError:
                available_apps = ", ".join([app.label for app in apps.get_app_configs()])
                self.stdout.write(
                    self.style.ERROR(
                        f'App "{app_label}" not found. Available apps: {available_apps}')
                )

                return

        self.stdout.write(
            self.style.SUCCESS(f'Successfully generated SQL statements in {sql_file_path}')
        )

    def create_tables_for_app(self, app_config, database, sql_file_path):
        # 获取应用中的所有模型
        models = app_config.get_models()

        for model in models:
            self.create_table_for_model(model, database, sql_file_path)

    def create_table_for_model(self, model, database, sql_file_path):
        # 获取数据库连接
        connection = connections[database]

        # 获取模型对应的创建表SQL
        with connection.schema_editor() as schema_editor:
            try:
                # 生成创建表的SQL语句而不是实际创建表
                table_name = model._meta.db_table
                schema_editor.deferred_sql = []  # 清空之前的SQL语句

                # 修复DatabaseSchemaEditor缺少_create_table_sql方法的问题
                # 使用正确的API来生成SQL语句
                columns = []
                for field in model._meta.fields:
                    # column_sql 返回的是一个tuple，我们需要的是第一个元素（SQL片段）
                    column_sql = schema_editor.column_sql(model, field)
                    if isinstance(column_sql, tuple):
                        # 修复：需要包含列名和列定义
                        column_def = column_sql[0]
                        column_name = schema_editor.quote_name(field.column)
                        columns.append(f"{column_name} {column_def}")
                    else:
                        column_name = schema_editor.quote_name(field.column)
                        columns.append(f"{column_name} {column_sql}")

                # 构建列定义部分
                coldefs = ", ".join(columns)
                
                # 添加主键自增定义（如果适用）
                if columns:
                    # 修复：使用正确的SQL模板
                    sql_statement = f"CREATE TABLE {schema_editor.quote_name(table_name)} ({coldefs})"

                # 将SQL语句写入文件
                with open(sql_file_path, 'a') as f:
                    f.write(f'-- Table: {table_name}\n')
                    f.write(f'{sql_statement};\n')

                    # 添加其他相关的SQL语句（如索引等）
                    for deferred_sql in schema_editor.deferred_sql:
                        if hasattr(deferred_sql, 'template'):
                            f.write(f'{deferred_sql.template % deferred_sql.parts};\n')
                        else:
                            f.write(f'{deferred_sql};\n')

                    f.write('\n')

                self.stdout.write(f'  Generated SQL for table {table_name}')
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'    Error generating SQL for {model._meta.db_table}: {str(e)}')
                )
