from django.core.management.base import BaseCommand
from django.db import connections
from django.db.utils import OperationalError
from django.apps import apps
import os


class Command(BaseCommand):
    help = 'Sync database tables without using migrations'

    def add_arguments(self, parser):
        parser.add_argument(
            '--database',
            default='default',
            help='Nominates a database to sync. Defaults to the "default" database.',
        )

    def handle(self, *args, **options):
        database = options['database']
        self.stdout.write(f'Syncing database: {database}')

        # 获取项目根目录并创建sql.txt文件路径
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
        sql_file_path = os.path.join(base_dir, 'sql.txt')
        
        # 清空或创建sql.txt文件
        with open(sql_file_path, 'w') as f:
            f.write('-- SQL Statements Generated by syncdb command\n')
            f.write('-- ===========================================\n\n')

        # 获取所有已安装的应用
        app_configs = apps.get_app_configs()

        # 为所有模型生成SQL语句并写入文件
        for app_config in app_configs:
            self.stdout.write(f'Processing app: {app_config.label}')
            try:
                self.create_tables_for_app(app_config, database, sql_file_path)
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'Error creating tables for {app_config.label}: {str(e)}')
                )

        self.stdout.write(
            self.style.SUCCESS(f'Successfully generated SQL statements in {sql_file_path}')
        )

    def create_tables_for_app(self, app_config, database, sql_file_path):
        # 获取应用中的所有模型
        models = app_config.get_models()

        for model in models:
            self.create_table_for_model(model, database, sql_file_path)

    def create_table_for_model(self, model, database, sql_file_path):
        # 获取数据库连接
        connection = connections[database]

        # 获取模型对应的创建表SQL
        with connection.schema_editor() as schema_editor:
            try:
                # 生成创建表的SQL语句而不是实际创建表
                table_name = model._meta.db_table
                schema_editor.deferred_sql = []  # 清空之前的SQL语句
                sql_statement = schema_editor._create_table_sql(model)
                
                # 将SQL语句写入文件
                with open(sql_file_path, 'a') as f:
                    f.write(f'-- Table: {table_name}\n')
                    f.write(f'{sql_statement};\n')
                    
                    # 添加其他相关的SQL语句（如索引等）
                    for deferred_sql in schema_editor.deferred_sql:
                        if hasattr(deferred_sql, 'template'):
                            f.write(f'{deferred_sql.template % deferred_sql.parts};\n')
                        else:
                            f.write(f'{deferred_sql};\n')
                    
                    f.write('\n')
                
                self.stdout.write(f'  Generated SQL for table {table_name}')
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'    Error generating SQL for {model._meta.db_table}: {str(e)}')
                )

